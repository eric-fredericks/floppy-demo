package org.kalergic.floppyears.codegen

import java.nio.file.{Path, Paths}

import scala.collection.mutable
import scala.meta._
import scala.meta.inputs.Input
import scala.util.control.NonFatal
import scala.util.{Failure, Success, Try}

private[codegen] class FloppyEarsSupportGenerator(
    routes: Map[String, Map[String, String]],
    inFilePath: Path,
    parsedSource: Source
) {
  import AnnotationDefinitions._
  import AnnotationParsing._
  import FloppyEarsSupportGenerator._

  // A place to hold the generated code in string form
  private[this] val outputBuilder: mutable.Builder[String, List[String]] =
    List.newBuilder[String]
  private[this] val importSet: mutable.Set[String] = mutable.Set.empty

  def generate(): Try[String] = Try {

    // A flag to tell is if code was actually generated
    var codeGenerated: Boolean = false
    var packageFound = false
    var currentPackageName: String = ""
    var currentTraitName: String = ""

    parsedSource.traverse {
      case q"package $ref { ..$_ }    " if !packageFound =>
        // This is the top of the file so we'll generate a file header
        packageFound = true
        currentPackageName = ref.syntax
        withGeneratedFileHeader()
        withPackage(currentPackageName)
        withRequiredImports()
      case q"..$_ trait $traitName[..$_] extends $_" =>
        val objName = s"${traitName.syntax}FloppyEarsSupport"
        currentTraitName = traitName.syntax
        startObject(objName)
      case q"package $ref { ..$_ }   " =>
        throw new Exception(s"Inner package $ref not supported in $inFilePath")
      case imp @ q"import ..$_" =>
        importSet += imp.syntax
      case q"..$mods def $mthName[..$typeParams](...$methodParams): $_ " =>
        val methodName = mthName.syntax
        val parsedMethodAnnotations = mods.parseAnnotations(s"$inFilePath")
        if (parsedMethodAnnotations.specifiesFloppyEarsInterceptable) {
          val fullyQualifiedMethodName = buildFullyQualifiedMethodName(
            currentPackageName,
            currentTraitName,
            methodName
          )
          withInterceptedMethodSupport(
            fullyQualifiedMethodName,
            methodName,
            parsedMethodAnnotations,
            typeParams,
            methodParams
          )
          codeGenerated = true
        }
    }
    endObject()

    // If we never found anything to generate (a method properly annotated), just throw away the package and imports and empty object.
    if (!codeGenerated)
      outputBuilder.clear()

    // And...generate the final output!
    outputBuilder.result.mkString("\n")
  }

  private[this] def buildFullyQualifiedMethodName(
      currentPackageName: String,
      currentTraitName: String,
      methodName: String
  ): String = {
    if (currentPackageName.isEmpty || currentTraitName.isEmpty || methodName.isEmpty) {
      throw new Exception(
        s"""Package, trait, or method is empty: package="$currentPackageName", trait="$currentTraitName", method="$methodName""""
      )
    }
    s"$currentPackageName.$currentTraitName.$methodName"
  }

  private[this] def withGeneratedFileHeader(): Unit = {
    outputBuilder +=
      """/**
        | * This code is generated by the Floppy Ears plugin.
        | * Do not hand-edit this code.
        | */
        |""".stripMargin
  }

  private[this] def withPackage(packageName: String): Unit = {
    outputBuilder += s"package $packageName"
    outputBuilder += ""
  }

  private[this] def withRequiredImports(): Unit = {
    outputBuilder += "import akka.util.ByteString"
    outputBuilder += "import com.sksamuel.avro4s.AvroSchema"
    outputBuilder += "import org.apache.avro.Schema"
    outputBuilder += "import org.json4s._"
    outputBuilder += "import org.kalergic.floppyears.wiretap.{ActionDef, ActionContext}"
    outputBuilder += "import org.kalergic.floppyears.wiretap.ParamNameNormalization._"
    outputBuilder += "import org.kalergic.floppyears.wiretap.PathParamExtraction._"
    outputBuilder += "import play.api.mvc.{ AnyContentAsJson, Request }"
    outputBuilder += "import play.api.libs.json._"
    outputBuilder += "import scala.concurrent.duration._"
    outputBuilder += "import scala.language.higherKinds"
    outputBuilder += "import scala.language.postfixOps"
    outputBuilder += ""
  }

  private[this] def startObject(objName: String): Unit = {
    outputBuilder +=
      s"""object $objName {
         |
         |  implicit val formats: Formats = DefaultFormats
         |""".stripMargin
  }

  private[this] def endObject(): Unit =
    outputBuilder += "}"

  private[this] def withInterceptedMethodSupport(
      fullyQualifiedMethodName: String,
      methodName: String,
      methodAnnotations: ParsedAnnotations,
      typeParams: Seq[Type.Param],
      methodParams: Seq[Seq[Term.Param]]
  ): Unit = {

    if (typeParams.nonEmpty) {
      throw new Exception(
        s"Type parameters are not supported: $fullyQualifiedMethodName"
      )
    }

    if (methodAnnotations.containsFloppyEarsParameterAnnotations) {
      throw new Exception(
        s"Methods annotated for FloppyEars interception cannot contain parameter annotations: ${supportedParameterAnnotations}, method: $fullyQualifiedMethodName"
      )
    }

    if (methodAnnotations.includesAnnotation(WiretapRequestTransform) && !methodAnnotations
          .includesAnnotation(WiretapRequest)) {
      throw new Exception(
        s"Cannot transform a request body when there is no request body specified: $fullyQualifiedMethodName. In order to use @$WiretapRequestTransform, you must also use @$WiretapRequest."
      )
    }

    if (methodAnnotations.includesAnnotation(WiretapResponseTransform) && !methodAnnotations
          .includesAnnotation(WiretapResponse)) {
      throw new Exception(
        s"Cannot transform a response body when there is no response body specified: $fullyQualifiedMethodName. In order to use @$WiretapResponseTransform, you must also use @$WiretapResponse."
      )
    }

    val majorVersion = methodAnnotations.majorVersion.getOrElse(
      throw new Exception(
        s"No major version specified: $fullyQualifiedMethodName"
      )
    )

    if (majorVersion < 0) {
      throw new Exception(
        s"Programmers who specify negative major versions (as was done for $fullyQualifiedMethodName) are less than zero."
      )
    }

    val actionName =
      methodAnnotations.actionName.getOrElse(methodName.capitalize)
    if (actionName.isEmpty) {
      throw new Exception(
        s"Action name cannot be empty for $fullyQualifiedMethodName"
      )
    }

    val actionRootName = s"${actionName}V${majorVersion}"
    val caseClassName = s"${actionRootName}Event"

    // Pull in imports. In order for a type to be included as a method parameter, it must have been imported by now.
    // Going "whole hog" and pulling in everything.
    val imports = importSet.mkString("\n  ")
    if (imports.nonEmpty) {
      outputBuilder += "  // Imports carried over from the unmanaged source file."
      outputBuilder += s"  $imports"
      outputBuilder += "  // END Imports carried over from the unmanaged source file."
      outputBuilder += ""
    }
    importSet.clear

    val floppyEarsContextGetterName: String =
      s"${actionRootName.uncapitalize}Context"

    // Build up associated case class
    val requestBodyProcessing: Option[BodyProcessing] =
      methodAnnotations.requestBodyProcessing
    val responseBodyProcessing: Option[BodyProcessing] =
      methodAnnotations.responseBodyProcessing
    val parseRequestJsonBody: Boolean =
      methodAnnotations.parseRequestJson.getOrElse(true)

    val filteredMethodParams = methodParams.flatten
      .map {
        case param @ Term.Param(mods, name, _, _) =>
          val parameterContext = s"$fullyQualifiedMethodName.${name.syntax}"
          MethodParameter(parameterContext, param, mods)
      }
      .filterNot(_.isIgnored)

    val requestClass = requestBodyProcessing.map(_.bodyClass)

    val responseClass = responseBodyProcessing.map(_.bodyClass)

    withCaseClass(
      actionName,
      majorVersion,
      caseClassName,
      requestClass,
      responseClass,
      filteredMethodParams
    )

    withCaseClassCompanionObject(
      fullyQualifiedMethodName,
      methodName,
      actionName,
      majorVersion,
      actionRootName,
      caseClassName,
      requestBodyProcessing,
      parseRequestJsonBody,
      responseBodyProcessing,
      filteredMethodParams
    )

    withFloppyEarsContextGetter(
      actionRootName,
      caseClassName,
      floppyEarsContextGetterName
    )
  }

  private[this] def withCaseClass(
      actionName: String,
      majorVersion: Int,
      caseClassName: String,
      requestClass: Option[String],
      responseClass: Option[String],
      methodParams: Seq[MethodParameter]
  ): Unit = {

    // Build up case class params
    val caseClassParams = List.newBuilder[String]
    caseClassParams += "_userId: Option[String]"
    caseClassParams += "_sessionId: Option[String]"

    methodParams.map(_.param).foreach {
      case Term.Param(_, name, tpe, _) =>
        caseClassParams += s"${name.syntax}: ${tpe.get.syntax}"
    }

    // Case class params: request body
    requestClass.foreach { clazz =>
      caseClassParams += s"_request: $clazz"
    }

    // Case class params: response body
    responseClass.foreach { clazz =>
      caseClassParams += s"_response: $clazz"
    }
    outputBuilder += ""

    // Generate case class
    outputBuilder +=
      s"""  // NOTE: Parameters with underscores are added by the code generator; parameters without underscores come from the
         |  // annotated controller trait we have parsed.
         |  case class $caseClassName(
         |    ${caseClassParams.result.mkString(",\n    ")}
         |  )
         |""".stripMargin
  }

  private[this] def withCaseClassCompanionObject(
      fullyQualifiedMethodName: String,
      methodName: String,
      actionName: String,
      majorVersion: Int,
      actionRootName: String,
      caseClassName: String,
      requestBodyProcessing: Option[BodyProcessing],
      parseRequestJsonBody: Boolean,
      responseBodyProcessing: Option[BodyProcessing],
      methodParams: Seq[MethodParameter]
  ): Unit = {

    val routeDefinedParams: Map[String, String] = routes.getOrElse(
      fullyQualifiedMethodName,
      throw new Exception(
        s"No route defined for @Wiretap annotated method $fullyQualifiedMethodName"
      )
    )

    def extractMethodParams(methodParam: MethodParameter): String =
      methodParam.extractExpr(routeDefinedParams)

    val caseClassConstructorParams = List.newBuilder[String]

    // NOTE: All parameters that are not coming from the declared controller trait method signature have a `_` prefix
    // to denote they are added by the framework. This is to reduce the likelihood of conflict with declared parameter names.
    caseClassConstructorParams += "_userId=_userId"
    caseClassConstructorParams += "_sessionId=_sessionId"

    methodParams.foreach { methodParam =>
      caseClassConstructorParams += extractMethodParams(methodParam)
    }

    val extractRequestExpr: Seq[String] = requestBodyProcessing
      .map {
        case BodyProcessing(rawBodyClass, bodyTransformation) =>
          caseClassConstructorParams += "_request = _request"

          val transformRequestBodyExpr = bodyTransformation
            .map {
              case BodyTransformation(targetClass, transformFn) =>
                s"val _request: $targetClass = $transformFn(requestBody)"
            }
            .getOrElse {
              s"val _request: $rawBodyClass = requestBody"
            }

          if (parseRequestJsonBody) {
            Seq(
              "val requestBodyAsJson: JsValue = request.body.asInstanceOf[JsValue]",
              s"val requestBody: $rawBodyClass = Json.fromJson[$rawBodyClass](requestBodyAsJson).get",
              transformRequestBodyExpr
            )
          } else {
            Seq(
              s"val requestBody = request.body.asInstanceOf[$rawBodyClass]",
              transformRequestBodyExpr
            )
          }
      }
      .getOrElse(Seq.empty)

    val extractResultExpr: Seq[String] = responseBodyProcessing
      .map {
        case BodyProcessing(rawBodyClass, bodyTransformation) =>
          caseClassConstructorParams += "_response = _response"

          val transformResponseBodyExpr = bodyTransformation
            .map {
              case BodyTransformation(targetClass, transformFn) =>
                s"val _response: $targetClass = $transformFn(responseBody)"
            }
            .getOrElse {
              s"val _response: $rawBodyClass = responseBody"
            }
          Seq(
            "val responseJsValue = Json.parse(bytes.toArray)",
            s"val responseBody: $rawBodyClass = Json.fromJson[$rawBodyClass](responseJsValue).get",
            transformResponseBodyExpr
          )
      }
      .getOrElse(Seq.empty)

    val extractExprs: String =
      (extractRequestExpr ++ extractResultExpr).mkString("\n      ")

    val requestParamsExpr: String = if (methodParams.nonEmpty) {
      s"""
         |      // Path params must be added to the map after the query string parameters, so parameter names (keys) are overwritten
         |      // in the map. Play should select the path parameters over query string parameters when dispatching to controllers.
         |      val requestParams = request.queryString.normalizeParamNames ++ request.pathParams.normalizeParamNames
         |""".stripMargin

    } else {
      ""
    }

    outputBuilder +=
      s"""  object $caseClassName {
         |
         |    implicit val ${caseClassName}Schema: Schema = AvroSchema[$caseClassName]
         |    val ${actionRootName}Action = ActionDef("$actionName", $majorVersion)
         |
         |    def create$caseClassName[R[_] <: Request[_]](
         |      request: R[_])(
         |      extractUserId: R[_] => Option[String])(
         |      extractSessionId: R[_] => Option[String])(
         |      bytes: ByteString): JObject = {
         |
         |      val _userId = extractUserId(request)
         |      val _sessionId = extractSessionId(request)
         |      $requestParamsExpr
         |      $extractExprs
         |      val event = $caseClassName(
         |        ${caseClassConstructorParams.result.mkString(",\n        ")})
         |      Extraction.decompose(event).asInstanceOf[JObject]
         |    }
         |  }
         |""".stripMargin
  }

  private[this] def withFloppyEarsContextGetter(
      rootName: String,
      caseClassName: String,
      floppyEarsContextGetterName: String
  ): Unit = {
    outputBuilder +=
      s"""  def $floppyEarsContextGetterName[R[_] <: Request[_]]: ActionContext[R] = {
         |      import ${caseClassName}._
         |      ActionContext[R](
         |        ${rootName}Action,
         |        ${caseClassName}Schema,
         |        create$caseClassName[R]
         |      )
         |    }
         |""".stripMargin
  }
}

object FloppyEarsSupportGenerator {

  def generateInterceptors(
      routes: Map[String, Map[String, String]],
      outPath: Path,
      infiles: Seq[String]
  ): Unit =
    infiles.map(p => Paths.get(p)).foreach { inFilePath =>
      val bytes: Array[Byte] = java.nio.file.Files.readAllBytes(inFilePath)
      val text: String = new String(bytes, "UTF-8")
      val input: Input = Input.VirtualFile(inFilePath.toString, text)
      val source: Source = input.parse[Source].get
      val outFileName = s"${inFilePath.getFileName}"
        .replace(""".scala""", """FloppyEarsSupport.scala""")

      new FloppyEarsSupportGenerator(routes, inFilePath, source)
        .generate() match {
        case Success(code) =>
          if (code.nonEmpty) {
            val outFilePath = Paths.get(outPath.toString, outFileName)
            java.nio.file.Files.write(outFilePath, code.getBytes("UTF-8"))
            println(s"Wrote file $outFilePath")
          }
        case Failure(NonFatal(e)) =>
          Console.err.println(
            s"ERROR generating output for code annotated in $inFilePath"
          )
          e.printStackTrace(Console.err)
          System.exit(2)
      }
    }

  implicit class Uncapitalize(str: String) {
    def uncapitalize: String =
      if (str == null) str
      else if (str.length == 0) str
      else if (str.charAt(0).isLower) str
      else {
        val chars = str.toCharArray
        chars(0) = chars(0).toLower
        new String(chars)
      }
  }
}
